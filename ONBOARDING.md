# Developer Onboarding
**NEMESIS Development Guide**

This document provides a technical overview of the NEMESIS codebase for new contributors. It covers the system architecture, data models, and development workflow.

## Architecture Overview

NEMESIS is built with **PySide6 (Qt)** and follows a modular design to support stability during long-duration experiments.

### Core Concepts

*   **Tabbed Workspace**: The main window (`app/main.py`) manages a list of tabs. Each tab acts as an isolated sandbox for a specific experimental rig or data view.
*   **RunSession**: Encapsulates the state of a live experiment, including the camera connection, serial link, active loggers, and hardware workers. This isolation ensures that a hardware failure in one tab does not affect others.
*   **Workers**: Heavy operations run in background threads to keep the UI responsive.
    *   `FrameWorker`: Handles video capture.
    *   `CVWorker`: Runs the computer vision pipeline (`cvbot.py`).
    *   `SerialLink`: Manages communication with the Arduino.

### Directory Structure

```text
run.py                     # Application entry point
app/
  main.py                  # UI logic and main application loop
  core/
    analyzer.py            # Post-run data correlation
    cvbot.py               # Computer vision tracking logic
    logger.py              # CSV logging implementation
    plotter.py             # Matplotlib integration
    scheduler.py           # Stimulus timing logic
    session.py             # State container
    video.py               # Video recording wrapper
  drivers/                 # Hardware interface layers
  ui/                      # Qt resources
assets/                    # Static assets (fonts, images)
firmware/                  # Arduino source code
```

## Data Pipeline

The system generates three primary data artifacts for each run, stored in `runs/run_YYYYMMDD_HHMMSS_<token>/`.

### 1. Stimulus Logs (`taps.csv`)
Records every mechanical event command sent to the hardware.
*   **t_host_ms**: Monotonic host timestamp.
*   **t_fw_ms**: Firmware execution timestamp (for latency verification).
*   **mode**: Schedule type (Periodic, Poisson, Replicant).
*   **mark**: Scheduled vs. Manual tap.
*   **frame_recorded_idx**: The specific video frame index corresponding to the tap.

### 2. Tracking Logs (`tracking.csv`)
Generated by the CV pipeline (`TrackingLogger`). Records the state of the organism for every processed frame.
*   **stentor_id**: Unique ID assigned to a tracked object.
*   **state**: Classification result (CONTRACTED, EXTENDED, UNDETERMINED).
*   **circularity/area**: Geometric features used for classification.

### 3. Metadata (`run.json`)
A snapshot of the configuration parameters used to initiate the run, ensuring reproducibility.

## Computer Vision System

The `cvbot.py` module implements a lightweight tracking system designed for robust performance over days of operation.

1.  **Segmentation**: Uses an adaptive threshold on the inverted Red channel to isolate the green Stentor against a white background.
2.  **Tracking**: Implements a "Home Base" logic. Since Stentor are anchored, the tracker associates moving blobs with a fixed anchor point to maintain identity despite rapid shape changes.
3.  **Classification**: Determines state based on circularity and the velocity of shape change (detecting rapid contractions).

## Development Workflow

### Setup
Follow the installation steps in the README. Ensure you have the project requirements installed in a virtual environment.

### Code Style
*   **Type Hinting**: Use Python type hints for all function signatures.
*   **Logging**: Use `APP_LOGGER` from `app.core.logger` instead of `print`.
*   **Conventions**: Follow existing naming conventions (snake_case for functions/variables, PascalCase for classes).

### Debugging
*   **Pro Mode**: Toggle in the UI to enable keyboard shortcuts for rapid testing.
*   **Hardware Simulation**: The application handles missing hardware gracefully. You can test UI logic without a camera or Arduino connected (warnings will appear, but the app will not crash).

### Release Process
1.  Update the version string in `VERSION` and `app/main.py`.
2.  Verify the `nemesis.spec` file encompasses new dependencies.
3.  Build the standalone executable using PyInstaller.