# Developer Onboarding
**NEMESIS Development Guide**

This document provides a technical overview of the NEMESIS codebase for new contributors. It covers the system architecture, data models, and development workflow.

## Architecture Overview

NEMESIS is built with **PySide6 (Qt)** and follows a modular design to support stability during long-duration experiments.

### Core Concepts

*   **Tabbed Workspace**: The main window (`app/main.py`) manages a list of tabs. Each tab acts as an isolated sandbox for a specific experimental arm or data view.
*   **RunSession**: Encapsulates the state of a live experiment, including the camera connection, serial link, active loggers, and hardware workers. This isolation ensures that a hardware failure in one tab does not affect others.
*   **Multiprocessing Engine**: To ensure a responsive UI on high-resolution displays, heavy computational tasks run in separate processes.
    *   **FrameWorker**: Runs in a thread, captures video frames, and writes them to a **Shared Memory Ring Buffer**.
    *   **ProcessCVWorker**: Manages a separate OS process (`run_cv_process`) that reads frames directly from RAM (Zero-Copy) to perform tracking analysis without blocking the main application loop (GIL-free).

### Directory Structure

```text
run.py                     # Application entry point
app/
  main.py                  # Entry point & Window Manager
  core/
    analyzer.py            # Post-run data correlation
    cvbot.py               # Computer vision tracking logic (Process entry point)
    ik_analysis.py         # Leighton-style I_k analysis pipeline
    logger.py              # CSV logging implementation
    paths.py               # Path resolution & constants
    plotter.py             # Matplotlib data-free plotting
    sequence_export.py     # ML sequence export utilities
    stimulus_partition.py  # Frame-level baseline/post-tap partitioning
    runlib.py              # Run metadata management
    scheduler.py           # Stimulus timing logic
    session.py             # State container (RunSession)
    shared_mem.py          # SharedMemoryManager for zero-copy IPC
    video.py               # Video capture & recording
    workers.py             # Background workers (FrameWorker, ProcessCVWorker)
  drivers/                 # Hardware interface layers
  ui/                      # UI Components
    tabs/                  # Major application tabs
      dashboard.py         # Data analysis & review tab
      run_tab.py           # Live experiment control tab
    widgets/               # Reusable widgets
      chart.py             # LiveChart (Matplotlib wrapper)
      containers.py        # Layout helpers (AspectRatio, TabBar)
      viewer.py            # Video preview (ZoomView)
    theme.py               # Styling & Palette definitions
assets/                    # Static assets (fonts, images)
firmware/                  # Arduino source code
tools/                     # CLI helpers (analysis/export/verification)
tests/                     # Pytest suite
```

## Data Pipeline

The system generates run artifacts in `runs/run_YYYYMMDD_HHMMSS_<token>/`.

### 1. Stimulus Logs (`taps.csv`)
Records every mechanical event command sent to the hardware.
*   **t_host_ms**: Monotonic host timestamp.
*   **t_fw_ms**: Firmware execution timestamp (for latency verification).
*   **mode**: Schedule type (Periodic, Poisson, Replicant).
*   **mark**: Scheduled vs. Manual tap.
*   **frame_recorded_idx**: The specific video frame index corresponding to the tap.

### 2. Tracking Logs (`tracking.csv`)
Generated by the CV pipeline (`TrackingLogger`). Records the state of the organism for every processed frame.
*   **stentor_id**: Unique ID assigned to a tracked object.
*   **state**: Classification result (CONTRACTED, EXTENDED, UNDETERMINED).
*   **state=NONE**: Explicit rows emitted when no detections are present in a frame (keeps the sequence dense).
*   **circularity/area**: Geometric features used for classification.
*   **edge_reflection**: Flag set when a detection falls near the dish edge (possible reflection).

### 3. Frame Timeline (`frames.csv`)
A full frame index + timestamp timeline for aligning taps and CV outputs, used for fixed-step ML exports.

### 4. Metadata (`run.json`)
A snapshot of the configuration parameters used to initiate the run, ensuring reproducibility.
*   **schema_version**: Incremented when run metadata format changes.
*   **arm_name**: Optional arm label shown in the UI and saved per run.
*   **run_start_host_ms**: Monotonic start time used as the alignment baseline.
*   **camera_fps / camera_frame_size / preview_fps**: Capture settings at run start.
*   **acclimation_min**: Pre-run settling period (minutes) before acquisition starts.
*   **cv_config**: CV thresholds and tracking parameters in effect during the run.
*   **low_disk_mode / tracking_log_decimate**: Logging throttle state if Low-Disk Mode is enabled.
*   **diagnostics_enabled / diagnostics_interval_s**: Health telemetry sampling settings (if diagnostics are enabled).

### ML Export Helper
Use `tools/export_sequences.py` to build fixed-step sequences (HMM/LSTM-ready) from a run folder.
See `docs/sample_sequence.csv` for the output shape.

### I_k / Stimulus Partition Helpers
Use these CLI tools for Leighton-style analysis:
* `tools/export_stimulus_partitions.py`: Writes frame-level baseline/post-tap masks.
* `tools/analyze_ik.py`: Produces `ik_by_k.csv`, `ik_qc.csv`, and `ik_analysis.json`.

State handling in `ik_analysis.py`:
* `CONTRACTED -> 1`
* `EXTENDED -> 0`
* `UNDETERMINED`, `NONE`, missing, and `edge_reflection=1` -> missing (`None`)

## Computer Vision System

The `cvbot.py` module implements a lightweight tracking system designed for robust performance over days of operation.

1.  **Segmentation**: Uses an adaptive threshold on the inverted Red channel to isolate the green Stentor against a white background.
2.  **Tracking**: Implements a "Home Base" logic with spatially-gated candidate matching. Since Stentor are anchored, the tracker associates moving blobs with a fixed anchor point while reducing pairwise comparisons in sparse/high-count scenes.
3.  **Classification**: Determines state based on circularity and the velocity of shape change (detecting rapid contractions).

## Dashboard/Run Library Notes

* Data tabs discover runs from:
  * default `~/Documents/NEMESIS/runs`
  * configured run output directory (if set)
  * legacy/dev `runs/` paths
* Deleting a run via Data tab removes:
  * the run directory
  * linked recording artifact(s) referenced by `recording_path` (including legacy `recording_*` folders when empty)

## Development Workflow

### Setup
Follow the installation steps in the README. Ensure you have the project requirements installed in a virtual environment.

### Code Style
*   **Type Hinting**: Use Python type hints for all function signatures.
*   **Logging**: Use `APP_LOGGER` from `app.core.logger` instead of `print`.
*   **Conventions**: Follow existing naming conventions (snake_case for functions/variables, PascalCase for classes).
*   **No Magic Numbers**: Promote literals to named constants at module scope. Prefer reuse and keep units explicit.
*   **Schema Awareness**: When changing run data formats, bump `schema_version` and update docs/tests.
*   **Theme Safety**: Use theme tokens (`BG`, `PLOT_FACE`, `TEXT`, etc.) instead of hardcoded colors.
*   **Error Handling**: Keep UI paths resilient (log, degrade gracefully, avoid crashing the run loop).
*   **Performance First**: Optimize hot paths (CV, render, logging) before adding features.
*   **Maintainability Second**: Favor clear structure, small functions, and predictable data flow.
*   **Keep Bloat Down**: Avoid unnecessary dependencies, duplicate logic, or heavy UI effects.

### Testing
The project includes a comprehensive test suite using `pytest`.
*   **Run All Tests**: `export PYTHONPATH=$PYTHONPATH:. && python -m pytest tests/`
*   **Coverage**: Includes Unit Tests for CV logic, Drivers (mocked), and State management.

### Debugging
*   **Pro Mode**: Toggle in the UI to enable keyboard shortcuts for rapid testing.
*   **Hardware Simulation**: The application handles missing hardware gracefully. You can test UI logic without a camera or Arduino connected (warnings will appear, but the app will not crash).

### Release Process
1.  Update the version string in `VERSION` and `app/main.py`.
2.  Verify the `nemesis.spec` file encompasses new dependencies.
3.  Build the standalone executable using PyInstaller.

## Future Work
*   **UNIT1 Firmware/Protocol**: The UNIT1 path (`firmware/unit1/` and `docs/protocol.md`) is experimental and not part of the current release. Keep Arduino (`firmware/arduino/`) as the supported production target until UNIT1 is fully implemented and validated.
